景色の対称性が高いと、ICPの返す値は飛び飛びになってしまう。
この実装を使う場合は、かならず後段で異常値処理などすること。

自己位置の異常検知、すなわち景色の対称性の検知に相互共分散行列が使えそう？
まだあんまちゃんと考えてない

General-ICPの考え方を取った上で、コスト関数に事前分布を組み込み(ベイズフィルタの要領で正当化できる？)、ガウス・ニュートン法でイテレートすることができるらしい(？)
これだと事前分布由来のコストにより、値の飛びを防げそう。検討の価値ありか。

長方形の地図データを手打ちで用意するのは怠いので、直方体から長方形面を生成できるツールがあると嬉しそう。検討。

そもそも図形データのコンフィグファイルからの読み出しを実装してないですね。検討。

APIで受け取るデータは`std::pair<sycl::buffer<T_> /* データ */, sotoba::SE3 /* データをセンサ座標系へ移す変換 */>`みたいな形のほうがいいかも。

センサ点群のフィルタリングが必要。上の要領で立体を渡し、内部に含まれる点を除外するとか。

ひとつの`q.submit`には1つの`q.parallel_for`などしか入れられない。破るとErrorが出たりSIGSEGVが出たりする。

どうしてもSIGSEGVを消せなかった。  
荒療治で`std::this_thread::sleep_for(1ms)`を入れた。ほぼSIGSEGVは出なくなった。鎮まり給え...

正常であろうとデータ点を間引いたほうが良いかもしれない。  
地図図形の数には寄らなそう？円筒の計算量はまだあんまり試せてない。  

イテレートを増やしすぎると`float`による計算は容易に消し飛ぶことがわかった。
しかし、poseの更新で正規化しているんだがな...それでも計算誤差の蓄積は防げないってことか？
毎回「間違った位置での修正」を行ってるわけで、そう考えると蓄積するのはとても謎い。バグがありそう。

テストでは20回ぐらいが最適そう？もう少し減らせそうか。
イテレート回数の定数倍がそのまま処理時間の定数倍につながってそうなんで、データ点の削減と合わせて考えたほうがいいかも

でもデータ点減らすほうが良い気がする。
まだセンサデータに誤差を載せてないので何とも言えないのは、そう。

遠い点ほど大きく寄与するのはロバストで無さそうか。相互分散行列の計算時、距離による減衰をかけてもいいのかもしれない？

流石にクラッシュが多すぎるんでoneAPIのicpxでのビルドも試した。なぜかSYCL_SIMPLE_SWIZZLESが効かないのでnamed_swizzles_mixin.hppの17行目に#defineしてやった。これ大丈夫なんか？

そういやAdaptiveCppでもvecの中にfriend classを追加したが、アレもダメだったんかな。アレのせいでSIGSEGVしてたならほんとにごめんだな。

ともかく、icpxでビルドしようとしている。

コンパイルできたのだが、opt/intel/oneapi/vtune/下のlibGLESv2.soでクラッシュする。こいつがSYCLを一切使ってないPangolinのコードでも起きたので、oneAPIの何かがしゃしゃり出ているようだ、とGeminiやChatGPTと推定した。

lddで実行ファイルを調べると、libEGL.soがvtune下のに解決されるらしい。

objdumpの出力をRPATH, RUNPATHでgrepかけたらビンゴだった
(最初RUNPATHを教えてもらえず、RPATHだけ調べてたのでめちゃくちゃ沼った)。

紆余曲折あり、icpxでビルド時に実行ファイルに埋め込まれるRUNPATHなるものの中に混入した上記パスが問題であるらしいとわかった。
RUNPATHより優先度の高いLD_LIBRARY_PATHで/usr/lib/x86_64-linux-gpuに無理やり解決させたところ、SYCLを含まないPangolinによるウィンドウ表示プログラム(ipcxでビルド)が無事動いた。
このとき、setvars.shはソースしてないターミナルでやった。やっぱあれ邪悪だよな。

追記: 邪悪なのはvtunesだったらしい。`intel-oneapi-vtunes`を`apt remove`したらsetvars.shしても動いた(`intel-oneapi-vtunes`はそもそもapt upgradeできない)

そもそもパスと動的リンクが邪悪なのでは？滅ぶべきでは？

あとCMake操作時にボケっとして意図せぬ操作をしていた(変更をinstall先に反映させずに首ひねってたり)ので、複雑すぎるCMakeも邪悪だと思う。

そもそも複数のコンパイラをよしなに＝意識せずに使いこなすなんて、人類には無理では？

C++滅びないかな。

時々ICPの結果が大きく外れるようだ。異常値を無視する処理を加えた。
結果、まあまあ動作するようになった！

異常値が出る理由は現状定かでない。

icpxなら`std::this_thread::sleep_for`も不要らしい。

続いて、点群のフィルタリングを実装したい。

10/3 stew_cpp_project_generatorを一新し、これによってプロジェクトを作り直した。
CMakeLists.txtまわりなどが大幅に変更された。
installとRPATHのあたりを正攻法で直せず(単に真面目に調べる気力がなかった)、RPATHまわりを全部消すことで無理やり対応している。
このため、作った実行ファイルはLD_LIBRARY_PATHなどでlibsycl.soやlibpango_display.soをただしく紐づけないと動かない。

また、testsの中にvisualize.cppを入れるほかなかったのも恥ずかしい限りだ。sotoba::test::Checkが使いたくて...
そもそもCheckをtest名前空間に入れなきゃよかったという話かもしれん。

Checkが云々というより、浮動小数点数を扱う型には`+ epsilon`や`* epsilon`ができなくてはならなくて、その上での比較が実装されるべきという話か。
Approxの実装を眺めつつ、誤差許容比較や誤差付きの世界を考えるべき

howto_use_cmake.mdを書かなきゃ(stew_cpp_project_generatorに入れるべきか？) あと気づいたらREADME.md消し飛んでたや。まあ古い説明しかなかったしいっか。